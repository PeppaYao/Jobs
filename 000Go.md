### 1、GPM模型

线程并发模型M:N

- 每个OS线程固定分配2M内存
- goroutine初始分配2kb，可以自动扩容，上限时1G，因此可以一次创建上万个Goroutine

P：Processor管理一组G队列，存储当前G的上下文，P提供了G运行时的一切资源和环境

G：Goroutine协程，一个g结构体，堆栈等

M：Mechine内核线程，实际工作的线程

P和M一一对应，P的默认值是系统的CPU核数

当G在系统调用产生阻塞时，P队列会找其他空闲的M进行继续执行。阻塞的G醒了以后，先找P队列放入，如果都满了则找全局队列放入。

Local run queue 本地P队列

global run queue 全局队列

当P为空以后，优先从全局队列中找需要执行的G，如果全局为空，则找其他P队列，从中取走一半进行执行。

### 2、反射

