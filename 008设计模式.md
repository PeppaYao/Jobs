## 设计模式

### 1、设计原则

- **单一职责**：一个类应该仅有一个引起它变化的原因。

- **开闭原则**：对扩展开放，对更改封闭。

- **接口隔离**：接口应该小而完备，不应该强迫客户程序依赖它们不用的方法。

- **Liskov替换**：子类必须能替换它们的基类IS-A

- **依赖倒置**：稳定模块不应该依赖于变化模块，两者都应该依赖于抽象。

	

**从封装变化角度对模式分类**

组件协作

- template method模板方法★★
- strategy策略模式★★
- observer/event观察者模式★★

单一职责

- decorator装饰器★★
- bridge桥模式

对象创建

- factory method★★工厂方法
- abstract method★★抽象工厂
- prototype原型模式
- builder构建器

对象性能：

- singleton单例模式★★
- flyweight享元模式

接口隔离

- facade门面模式
- proxy代理模式★★
- mediator中介者
- adapter适配器

状态变化

- memento备忘录
- state状态模式

数据结构

- composite组合模式
- iterator迭代器
- chain of responsibility职责链

行为变化

- command命令模式
- visitor访问器

领域问题

- interpreter解析器

### 2、单例模式

保证一个类仅有一个实例，并提供一个该实例的全局访问点。

### 3、观察者模式

优点：解耦，添加观察者不用修改代码

### 4、工厂方法Factory Method 

定义一个用于创建对象的接口，**让子类决定实例化哪个类**，Factory method使得一个类的实例化延迟到子类。

目的：解耦

手段：虚函数

[视频链接](https://www.bilibili.com/video/BV1kW411P7KS?p=8)

### 5、抽象工厂Abstract Factory

抽象工厂针对**产品族**，而不是产品等级结构。

产品族：同一产地或者同一厂商，功能不同。

产品等级结构：功能相同产地或者厂商不同。

> 中国工厂：苹果 香蕉 梨
>
> 美国工厂：苹果 香蕉 梨
>
> 日本工厂：苹果 香蕉 梨

每个工厂属于一个产品族，每个水果属于产品等级结构。