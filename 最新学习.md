## JVM学习

### 1、Java内存结构

-   程序计数器
-   虚拟机栈
-   本地方法栈
-   堆
-   方法区

**线程私有：**程序计数器，虚拟机栈，本地方法栈。

**线程共享：**堆，方法区。

### 2、程序计数器

**作用：**用于记住下一条jvm指令的执行地址

**特点：**线程私有，不会存在内存溢出。

>   程序计数器可以看作是当前线程锁执行的字节码的行号提示器。

### 3、虚拟机栈

栈：线程运行时需要的内存空间，由多个栈帧组成。

栈帧：每个方法运行时需要的内存。(局部变量，返回地址)

活动栈帧：每个线程只能由一个活动栈帧，对应着当前正在执行的那个方法。(在栈顶)

设置栈大小：-Xss

linux/macOS下栈内存默认大小为1M

windows下取决于虚拟内存大小

栈内存溢出：栈帧过多(递归调用过深)，栈帧过大。

查看占用CPU过高的线程：

```shell
ps H -eo pid,tid,%cpu | grep 32655 
```

### 4、堆

通过new创建的对象都会使用堆内存

特点：线程共享，堆中对象都需要考虑线程安全的问题。有垃圾回收机制。

堆内存设置：-Xmx8m 默认时4G

###  5、方法区

jdk1.8中stringTable放在堆中，其他放在本地内存。

### 6、垃圾回收

如何判断对象可以回收：

1.  引用计数(循环引用问题)
2.  可达性分析

Java虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象。

扫描堆中的对象，看是否能够沿着gc root对象为起点的引用链找到该对象，找不到，表示不可回收。

### 7、垃圾回收算法

-   标记清除Mark-Sweep
-   标记整理 Mark-Compact
-   复制copying

### 8、分代

1.  年轻代：Eden from_servivor to_servivor 8:1:1
2.  老年代:

### 9、垃圾回收器

1.  serial 串行GC
2.  PS 并行GC **jdk1.8默认**
3.  CMS 并行执行垃圾回收同时不阻塞应用程序(STW=200ms)
4.  G1(STW=10ms)  **jdk1.9默认**
5.  ZGC(STW=1ms) 

### 10、Java内存模型

Java memory model = JMM

其实Java线程内存模型，是基于cpu缓存模型建立起来的。

线程有独占的工作内存，是共享内存的副本拷贝。

violate保证多个线程之间变量的可见性。

数据原子操作。read/write/load/store/assign/use/lock/unlock



## Java基础

### 1、JavaBean

-   JavaBean是一种Java语言写成的可重用组件
    -   私有属性
    -   属性对应的get和set方法

### 2、StringBuilder

字符串缓冲区，可以提高字符串的操作效率，底层也是数组，但是没有被final修饰。

```java
byte[] value = new byte[16]
```

如果超出了容量会自动扩容。

```java
StringBuilder()构造一个不带任何字符的字符串生成器，其初始容量为16个字符。
sb.append("abc").append("edf") 链式编程   
String s = "123";
//StringBuilder 转 String
StringBuilder sb = new StringBuilder(s);
//String 转 StringBuilder
System.out.println(sb.toString());
```

### 3、迭代器

```java
List<String> list = new ArrayList<>();
        list.add("张无忌");
        list.add("张翠山");
        list.add("张三丰");
        list.add("赵敏");
        list.add("周芷若");
        Iterator<String> it = list.iterator();
        while(it.hasNext()){
            String e = it.next();
            System.out.println(e);
        }
```

### 4、Map集合

```java
public class Test {
    public static void main(String[] args) {
       /*
       * 1. put(key, value) 如果没重复返回null，有重复返回被覆盖的value
       * 2. get(key) 如果key存在返回被删除的值 如果不存在返回null
       * 3. remove(key) 如果key存在返回被删除的值 如果不存在返回null
       * 4. containsKey(key) 返回布尔值
       * 5. keySet() 所有的key
       * 6. entrySet() 所有的key,value集合
       * 7. isEmpty() 判空
       * hashmap自定义类型为key必须重写hashcode和equals方法以保证key唯一
       * */
        Map<String, String> map = new HashMap();
        map.put("谢霆锋","王菲");
        map.put("黄晓明","杨颖");
        map.put("文章","马伊利");
        /*增强for循环方式*/
        Set<String> set = map.keySet();
        for(String s: map.keySet()){
            System.out.println(map.get(s));
        }
        System.out.println("====================");
        /*迭代器方式*/
        Iterator<String> it = set.iterator();
        while(it.hasNext()){
            String s = it.next();
            System.out.println(map.get(s));
        }
        System.out.println("====================");
        Set<Map.Entry<String, String>> s = map.entrySet();
        Iterator<Map.Entry<String, String>> its = s.iterator();
        while (its.hasNext()){
            Map.Entry<String, String> entry = its.next();
            System.out.println(entry.getKey() + " " + entry.getValue());
        }
    }
}
```

### 5、数组拷贝arraycopy

两个静态方法

```java
System.currentTimeMillis()  当前时间
arraycopy(src, srcPos, dest, destPos, length) 数组拷贝
```

举个栗子

```java
import static java.lang.System.arraycopy;
public class time {
    public static void main(String[] args) {
        /*当前系统的时间 毫秒System.currentTimeMillis()*/
        long st = System.currentTimeMillis();
        for(int i = 0; i < 100000; i++){
            System.out.println(i);
        }
        long ed = System.currentTimeMillis();
        System.out.println(ed-st);
        /*数组拷贝函数 arraycopy(src, srcPos, dest, destPos, length)*/
        int src[] = {1,2,3,4,5};
        int dest[] = {6,7,8,9,10};
        /*把前3个赋值到目标数组*/
        arraycopy(src, 0, dest, 0, 3);
        for(int i = 0; i < dest.length; i++){
            System.out.println(dest[i]);
        }
    }
}
```

### 6、StringBuilder

**StringBuilder 可变的字符串，效率高，非线程安全。**

```java
public class time {
    public static void main(String[] args) {
        StringBuilder sb = new StringBuilder();
        sb.append("hello").append(" world");
        sb.reverse();
        System.out.println(sb);
        /*String和StringBuilder的互相转换*/
        String s = sb.toString();
        StringBuilder ssb = new StringBuilder(s);
        System.out.println(ssb);
    }
}
```

### 7、FlatMap的使用

```java
import java.util.Arrays;

class Test{
    public static void main(String[] args) {
       int[][] data = {{1,2},{3,4}};
        Arrays.stream(data).flatMapToInt(x-> Arrays.stream(x)).forEach(x-> System.out.println(x));
    }
}
```

### 8、注解

Java注解是附在代码中的一些元信息，便于一些工具在编译，运行时进行解析和使用，起到说明，配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。
内置注解和元注解

```yaml
Deprecated: 已过时
Override:重写
SuppressWarnings:阻止警告
SafeVarargs:参数安全类型
FunctionalInterface:函数式接口
```



元注解负责注解自定义注解

```yaml
Retention:什么时候使用该注解
Target:注解用于什么地方
Documented:注解是否将包含在JavaDoc中
Inherited:是否允许子类继承该注解
Repeatable:指定注解可重复使用
```

### 9、反射

**这种动态获取的信息以及动态调用对象的方法的功能称为反射机制。**

1. 在JRE中有且仅有一个不变的class类型的对象，且只能由系统建立。

2. 一般获取class对象有三种方式：

  - 通过**类名获取**：类名.class。多用于参数的传递。

  - 通过**对象获取**，对象.getClass()。多用于对象的获取字节码的方式。

  - 通过**全类名获取**, Class.forName(全类名)。多用于配置文件。

    反射的好处：

    - **可以在程序运行过程中，操作这些对象。**
    - **可以解耦，提高程序的可扩展性。**

    结论：同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的class对象都是同一个。

3. class对象
  获取成员变量们getFields
   获取构造方法们getConstructors
    获取成员方法们getMethods
    获取类名getName

### 10、日志

```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class Test {
    public static void main(String[] args) {
        Logger logger = LoggerFactory.getLogger(Test.class);
        logger.info("Hello world");
    }
}
```

### 11、HashCode的作用

是将数据依特定算法直接指定到一个地址上。hashCode方法实际上返回的就是对象存储的物理地址（实际可能并不是）。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址。

1、如果两个对象equals相等，那么这两个对象的HashCode一定也相同

2、如果两个对象的HashCode相同，不代表两个对象就相同，只能说明这两个对象在散列存储结构中，存放于同一个位置。

hashcode就是通过hash函数得来的，通俗的说，就是通过某一种算法得到的，hashcode就是在hash表中有对应的位置。 

**hashcode代表对象的地址说的是对象在hash表中的位置，物理地址说的对象存放在内存中的地址** 

**HashCode的存在主要是为了查找的快捷性** 

先通过hashcode来比较，如果hashcode相等，那么就用equals方法来比较两个对象是否相等。 

## Java多线程

### 1、线程实现

-   创建线程方式1：继承Thread类，重写run方法，调用start开启线程。

```java

public class TestThread extends Thread{
    @Override
    public void run() {
        for(int i = 0; i < 1000; i++){
            System.out.println("我在学习...");
        }
    }

    public static void main(String[] args) {
        TestThread testThread = new TestThread();
        testThread.start();
        for(int i = 0; i < 1000; i++){
            System.out.println("主线程...");
        }
    }
}
```

-   创建线程方式2：实现runnable接口，重写run方法，新建线程对象同时传入实现类对象，执行start方法开启线程。推荐使用：避免单继承局限性，灵活方便，方便同一个对象被多个线程使用。

```java
public class TestThread implements Runnable{
    @Override
    public void run() {
        for(int i = 0; i < 1000; i++){
            System.out.println("我在学习...");
        }
    }

    public static void main(String[] args) {
        //创建线程对象 传入实现类对象
        TestThread testThread = new TestThread();
        new Thread(testThread).start();
        //主线程
        for(int i = 0; i < 1000; i++){
            System.out.println("主线程...");
        }
    }
}
```

### 2、函数式接口

-   函数式接口：接口中只含有一个抽象方法的。

### 3、线程状态

-   创建
-   就绪状态
-   运行状态
-   阻塞状态
-   死亡  

```java
setPriority()
sleep()
join()
yield()
isAlive()
```

建议使用一个标志位进行终止变量，当flag=false，则终止线程运行。

  

  

