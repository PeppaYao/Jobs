## JVM学习

### 1、Java内存结构

-   程序计数器
-   虚拟机栈
-   本地方法栈
-   堆
-   方法区

**线程私有：**程序计数器，虚拟机栈，本地方法栈。

**线程共享：**堆，方法区。

### 2、程序计数器

**作用：**用于记住下一条jvm指令的执行地址

**特点：**线程私有，不会存在内存溢出。

>   程序计数器可以看作是当前线程锁执行的字节码的行号提示器。

### 3、虚拟机栈

栈：线程运行时需要的内存空间，由多个栈帧组成。

栈帧：每个方法运行时需要的内存。(局部变量，返回地址)

活动栈帧：每个线程只能由一个活动栈帧，对应着当前正在执行的那个方法。(在栈顶)

设置栈大小：-Xss

linux/macOS下栈内存默认大小为1M

windows下取决于虚拟内存大小

栈内存溢出：栈帧过多(递归调用过深)，栈帧过大。

查看占用CPU过高的线程：

```shell
ps H -eo pid,tid,%cpu | grep 32655 
```

### 4、堆

通过new创建的对象都会使用堆内存

特点：线程共享，堆中对象都需要考虑线程安全的问题。有垃圾回收机制。

堆内存设置：-Xmx8m 默认时4G

###  5、方法区

jdk1.8中stringTable放在堆中，其他放在本地内存。

### 6、垃圾回收

如何判断对象可以回收：

1.  引用计数(循环引用问题)
2.  可达性分析

Java虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象。

扫描堆中的对象，看是否能够沿着gc root对象为起点的引用链找到该对象，找不到，表示不可回收。

### 7、垃圾回收算法

-   标记清除Mark-Sweep
-   标记整理 Mark-Compact
-   复制copying

### 8、分代

1.  年轻代：Eden from_servivor to_servivor 8:1:1
2.  老年代:

### 9、垃圾回收器

1.  serial 串行GC
2.  PS 并行GC **jdk1.8默认**
3.  CMS 并行执行垃圾回收同时不阻塞应用程序(STW=200ms)
4.  G1(STW=10ms)  **jdk1.9默认**
5.  ZGC(STW=1ms) 

### 10、Java内存模型

Java memory model = JMM

其实Java线程内存模型，是基于cpu缓存模型建立起来的。

线程有独占的工作内存，是共享内存的副本拷贝。

violate保证多个线程之间变量的可见性。

数据原子操作。read/write/load/store/assign/use/lock/unlock







## Java基础

### 1、JavaBean

-   JavaBean是一种Java语言写成的可重用组件
    -   私有属性
    -   属性对应的get和set方法

### 2、StringBuilder

字符串缓冲区，可以提高字符串的操作效率，底层也是要给数组，但是没有被final修饰。

```java
byte[] value = new byte[16]
```

如果超出了容量会自动扩容。

```java
StringBuilder()构造一个不带任何字符的字符串生成器，其初始容量为16个字符。
sb.append("abc").append("edf") 链式编程
 ----------------------------------------------------------------------------------   
String s = "123";
//StringBuilder 转 String
StringBuilder sb = new StringBuilder(s);
//String 转 StringBuilder
System.out.println(sb.toString());
```

### 3、迭代器

```java
List<String> list = new ArrayList<>();
        list.add("张无忌");
        list.add("张翠山");
        list.add("张三丰");
        list.add("赵敏");
        list.add("周芷若");
        Iterator<String> it = list.iterator();
        while(it.hasNext()){
            String e = it.next();
            System.out.println(e);
        }
```

### 4、Map集合

```java
public class Test {
    public static void main(String[] args) {
       /*
       * 1. put(key, value) 如果没重复返回null，有重复返回被覆盖的value
       * 2. get(key) 如果key存在返回被删除的值 如果不存在返回null
       * 3. remove(key) 如果key存在返回被删除的值 如果不存在返回null
       * 4. containsKey(key) 返回布尔值
       * 5. keySet() 所有的key
       * 6. entrySet() 所有的key,value集合
       * 7. isEmpty() 判空
       * hashmap自定义类型为key必须重写hashcode和equals方法以保证key唯一
       * */
        Map<String, String> map = new HashMap();
        map.put("谢霆锋","王菲");
        map.put("黄晓明","杨颖");
        map.put("文章","马伊利");
        /*增强for循环方式*/
        Set<String> set = map.keySet();
        for(String s: map.keySet()){
            System.out.println(map.get(s));
        }
        System.out.println("====================");
        /*迭代器方式*/
        Iterator<String> it = set.iterator();
        while(it.hasNext()){
            String s = it.next();
            System.out.println(map.get(s));
        }
        System.out.println("====================");
        Set<Map.Entry<String, String>> s = map.entrySet();
        Iterator<Map.Entry<String, String>> its = s.iterator();
        while (its.hasNext()){
            Map.Entry<String, String> entry = its.next();
            System.out.println(entry.getKey() + " " + entry.getValue());
        }
    }
}
```

## Java多线程

### 1、线程实现

-   创建线程方式1：继承Thread类，重写run方法，调用start开启线程。

```java

public class TestThread extends Thread{
    @Override
    public void run() {
        for(int i = 0; i < 1000; i++){
            System.out.println("我在学习...");
        }
    }

    public static void main(String[] args) {
        TestThread testThread = new TestThread();
        testThread.start();
        for(int i = 0; i < 1000; i++){
            System.out.println("主线程...");
        }
    }
}
```

-   创建线程方式2：实现runnable接口，重写run方法，新建线程对象同时传入实现类对象，执行start方法开启线程。推荐使用：避免单继承局限性，灵活方便，方便同一个对象被多个线程使用。

```java
public class TestThread implements Runnable{
    @Override
    public void run() {
        for(int i = 0; i < 1000; i++){
            System.out.println("我在学习...");
        }
    }

    public static void main(String[] args) {
        //创建线程对象 传入实现类对象
        TestThread testThread = new TestThread();
        new Thread(testThread).start();
        //主线程
        for(int i = 0; i < 1000; i++){
            System.out.println("主线程...");
        }
    }
}
```

### 2、函数式接口

-   函数式接口：接口中只含有一个抽象方法的。

### 3、线程状态

-   创建
-   就绪状态
-   运行状态
-   阻塞状态
-   死亡  

```java
setPriority()
sleep()
join()
yield()
isAlive()
```

建议使用一个标志位进行终止变量，当flag=false，则终止线程运行。

## SpringBoot学习笔记

1. 创建maven工程

	

2. 添加父依赖

	```java
	<parent>
	        <groupId>org.springframework.boot</groupId>
	        <artifactId>spring-boot-starter-parent</artifactId>
	        <version>2.3.2.RELEASE</version>
	 </parent>
	```

3. 添加Web依赖