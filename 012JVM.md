## JVM学习

### 1、Java内存结构★★

- 程序计数器
- 虚拟机栈
- 本地方法栈
- 堆
- 方法区

**线程私有：**程序计数器，虚拟机栈，本地方法栈。

**线程共享：**堆，方法区。

### 2、程序计数器

**作用：**用于记住下一条jvm指令的执行地址

**特点：**线程私有，不会存在内存溢出。

> 程序计数器可以看作是当前线程锁执行的字节码的行号提示器。

### 3、虚拟机栈

栈：线程运行时需要的内存空间，由多个栈帧组成。

栈帧：每个方法运行时需要的内存。(局部变量，返回地址)

活动栈帧：每个线程只能由一个活动栈帧，对应着当前正在执行的那个方法。(在栈顶)

设置栈大小：-Xss

linux/macOS下栈内存默认大小为1M

windows下取决于虚拟内存大小

栈内存溢出：栈帧过多(递归调用过深)，栈帧过大。

查看占用CPU过高的线程：

```shell
ps H -eo pid,tid,%cpu | grep 32655 
```

### 4、堆

通过new创建的对象都会使用堆内存

特点：线程共享，堆中对象都需要考虑线程安全的问题。有垃圾回收机制。

堆内存设置：-Xmx8m 默认时4G

### 5、方法区

jdk1.8中stringTable放在堆中，其他放在本地内存。

### 6、垃圾回收

如何判断对象可以回收：

1. 引用计数(循环引用问题)
2. 可达性分析

Java虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象。

扫描堆中的对象，看是否能够沿着gc root对象为起点的引用链找到该对象，找不到，表示不可回收。

### 7、垃圾回收算法★★

- 标记清除Mark-Sweep
- 标记整理 Mark-Compact
- 复制copying

### 8、分代

1. 年轻代：Eden from_servivor to_servivor 8:1:1
2. 老年代:

### 9、垃圾回收器★★

1. serial 串行GC
2. PS 并行GC **jdk1.8默认**
3. CMS 并行执行垃圾回收同时不阻塞应用程序(STW=200ms)
4. G1(STW=10ms)  **jdk1.9默认**
5. ZGC(STW=1ms) 

### 10、Java内存模型★★

Java memory model = JMM

其实Java线程内存模型，是基于cpu缓存模型建立起来的。

线程有独占的工作内存，是共享内存的副本拷贝。

violate保证多个线程之间变量的可见性。

数据原子操作。read/write/load/store/assign/use/lock/unlock

### 11、双亲委派机制★★

当某个类加载器需要加载某个`.class`文件时，它首先把这个任务委托给他的上级类加载器，递归这个操作，如果上级的类加载器没有加载，自己才会去加载这个类。 

类加载器的类别：

- 启动类加载器BootstrapClassLoader(C++编写) rt.jar
- 扩展类加载器ExtClassLoader jre/lib/ext
- 系统类加载器AppClassLoader classpath
- 自定义加载器CustomClassLoader



如果都没加载成功，抛出异常**Class Not Found**

作用：

1、防止重复加载同一个`.class`。通过委托去向上面问一问，加载过了，就不用再加载一遍。保证数据安全。
 2、保证核心`.class`不能被篡改。通过委托方式，不会去篡改核心`.clas`，即使篡改也不会去加载，即使加载也不会是同一个`.class`对象了。不同的加载器加载同一个`.class`也不是同一个`Class`对象。这样保证了`Class`执行安全。

### 13、Java内存结构和内存模型的区别

Java内存结构：程序计数器，虚拟机栈，堆，本地方法栈，方法区。

线程私有：程序计数器，虚拟机栈，本地方法栈。

线程共享：堆，方法区。

Java内存模型：定义了一套在多线程读写共享数据时，对数据的可见性，有序性和原子性的规则和保障。

### 14、Rest风格

**Rest指的是一组架构约束条件和原则** 

每个URI代表一种资源，这个请求基于HTTP，使用GET、POST、PUT、DELETE4个分别表示增删改查4种操作方式服务端资源进行操作。 

z

### 15、Java的BIO，NIO和AIO★★

BIO：blocking IO 同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。 

NIO：non-blocking IO 是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。 它支持面向缓冲的，基于通道的I/O操作方法。 

AIO：asynchronous IO 它是异步非阻塞的IO模型。 异步IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。 